<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Intel&reg; X86 Encoder Decoder: Intel&reg; X86 Encoder Decoder User Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Intel&reg; X86 Encoder Decoder
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Intel&reg; X86 Encoder Decoder User Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>April 2024</p>
<h1><a class="anchor" id="INTRO"></a>
Introduction</h1>
<p>Intel&reg; XED is an acronym for X86 Encoder Decoder. The latter part is pronounced like the (British) English "z".</p>
<p>Intel&reg; X86 Encoder Decoder (Intel&reg; XED) is a software library (and associated headers) written in C for encoding and decoding X86 (IA-32 instruction set and Intel&reg; 64 instruction set) instructions. The decoder takes sequences of 1-15 bytes along with machine mode information and produces a data structure describing the opcode and operands, and flags. The generic encoder takes a similar data structure and produces a sequence of 1 to 15 bytes.</p>
<p>There is another encoder called "enc2" available that is much faster than the generic encoder mentioned above. Rather than using a generic interface, in enc2, instruction encoding is done by calling one of a very large number of functions, passing as arguments the registers and constants that would be used in the assembly language description of the instruction. There are two interfaces to the enc2 encoder: unchecked and checked. The unchecked version is faster and assumes that the arguments passed in are in the correct ranges. The checked version validates that the arguments passed in are in the correct ranges and if that succeeds, it calls the corresponding unchecked version of the function. The checking can be skipped if desired using a runtime setting. The enc2 encoder is available in builds with the "--enc2" option. Due to the large amount of code generated, that build takes longer.</p>
<p>Intel&reg; XED is multi-thread safe.</p>
<p>Intel&reg; XED was designed to be very fast and extensible.</p>
<p>Intel&reg; XED compiles with the following compilers: </p><ul>
<li>
GNU GCC </li>
<li>
Microsoft Visual Studio </li>
<li>
LLVM/Clang </li>
</ul>
<p>Intel&reg; XED works with the following operating systems: </p><ul>
<li>
Linux </li>
<li>
Microsoft Windows (with and without cygwin) </li>
<li>
FreeBSD </li>
</ul>
<p>The Intel&reg; XED examples (<a class="el" href="group__EXAMPLES.html">Examples of using Intel&reg; XED</a>) also include binary image readers for Windows PECOFF, ELF, and Mac OS X* MACHO binary file formats for 32b and 64b. These allow Intel&reg; XED to be used as a simple (not symbolic) disassembler. The Intel&reg; XED disassembler supports 3 output formats: Intel, ATT SYSV, and a more detailed internal format describing all resources read and written.</p>
<h1><a class="anchor" id="TOC"></a>
Table of Contents</h1>
<ul>
<li><a class="el" href="index.html#BUILD">Building</a> Building your program with Intel&reg; XED</li>
<li><a class="el" href="index.html#EXTERN">External</a> External Requirements</li>
<li><a class="el" href="index.html#TERMS">Terms</a> Terminology</li>
<li><a class="el" href="index.html#OVERVIEW">Overview</a> Overview of the Intel&reg; XED approach</li>
<li><a class="el" href="index.html#API_REF">API reference</a> Detailed descriptions of the API</li>
<li><a class="el" href="group__EXAMPLES.html">Examples</a> Examples</li>
<li><a class="el" href="index.html#LEGAL">Disclaimer and Legal Information</a> <br  />
</li>
</ul>
<h1><a class="anchor" id="BUILD"></a>
Building your program using Intel® XED.</h1>
<p>This section describes the requirements for compiling with Intel&reg; XED and linking the libxed.a library. It assumes you are building from an Intel&reg; XED kit and not directly from the sources. (See the "install" option in the Intel&reg; XED build manual for information on making kits).</p>
<p>The structure of a Intel&reg; XED kit is as follows: </p><div class="fragment"><div class="line">               |-bin------</div>
<div class="line">               |-doc------|-html-</div>
<div class="line">               |-examples-</div>
<div class="line">|-xed-kit-name-|-include--</div>
<div class="line">               |-lib------</div>
<div class="line">               |-misc-----</div>
</div><!-- fragment --><p>To use Intel&reg; XED your sources should include the top-most header file: <a class="el" href="xed-interface_8h.html">xed-interface.h</a>.</p>
<p>Your compilation statement must include: </p><div class="fragment"><div class="line">-Ixed-kit-name/include</div>
</div><!-- fragment --><p> where "xed-kit-name" is where you've unpacked the Intel&reg; XED kit.</p>
<p>Your Linux or Mac OS X* link statement must reference the libxed library: </p><div class="fragment"><div class="line">-Lxed-kit-name/lib -lxed</div>
</div><!-- fragment --><p>(or link against xed.lib for Windows).</p>
<p>Intel&reg; XED uses base types with the following names: xed_uint8_t, xed_uint16_t, xed_uint32_t, xed_uint64_t xed_int8_t, xed_int16_t, xed_int32_t, and xed_int64_t. Intel&reg; XED also defines a "xed_uint_t" type that is shorthand for "unsigned int".</p>
<p>Please see the section <a class="el" href="group__INIT.html">Intel&reg; XED initialization</a> for more information about using Intel&reg; XED, and also the examples in <a class="el" href="group__EXAMPLES.html">Examples of using Intel&reg; XED</a>.</p>
<h1><a class="anchor" id="EXTERN"></a>
External Requirements</h1>
<p>Intel&reg; XED was designed to have minimal external requirements. Intel&reg; XED makes no system calls. Intel&reg; XED allocates no memory. (The examples are different). The following external functions/symbols are required for linking a program with libxed, with one caveat: The functions fprint and abort and the data object stderr are optional. If users register their own abort handler using <a class="el" href="group__INIT.html#ga017b6fcac483ea9f1621c4cdd0af84bd">xed_register_abort_function</a> () , then fprintf, stderr, and abort are not required and can be stubbed out to satisfy the linker.</p>
<p>Required: </p><ul>
<li>
memcmp </li>
<li>
memcpy </li>
<li>
memset </li>
<li>
strcmp </li>
<li>
strlen </li>
<li>
strncat </li>
</ul>
<p>Optional: </p><ul>
<li>
abort </li>
<li>
fprintf </li>
<li>
stderr </li>
</ul>
<h1><a class="anchor" id="TERMS"></a>
Terminology</h1>
<p>X86 instructions are 1-15 byte values. They consist of several well-defined components: </p><ul>
<li>
<p class="startli">Prefix bytes. </p><ul>
<li>
<p class="startli">Legacy prefix bytes used for many purposes (described further below).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">REX prefix byte but only in 64b mode. It has 4 1-bit fields: W, R, X, and B. The W bit modifies the operation width. The R, X and B fields extend the register encodings. The REX byte must be right before the opcode bytes else it is ignored.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">REX2 prefix, a 2-byte variant of the REX prefix, introduced with Intel&reg; APX extensions (see <a class="el" href="index.html#APX">Intel&reg; APX</a>), adds 16 Extended General Purpose Registers (EGPRs) across the legacy instruction set. It has eight 1-bit fields: M0, R4, X4, B4, W, R3, X3 and B3. R3, X3, B3 and W bits are the same as R, X and B bits in the REX prefix. While R4, X4, and B4 are additional bits used to encode the 32 EGPR registers. M0 bit selects between legacy maps 0 and 1 (1-byte opcodes no escape and 2-byte opcodes escape 0x0F respectively).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">VEX prefix byte sequence. The VEX prefix is used mostly for AVX1 and AVX2 instructions as well as BMI1/2 instructions and mask operations in Intel&reg; AVX512. The VEX prefix comes in two forms. The 2-byte sequence begins with an 0xC5 byte. The 3-byte sequence begins with an 0xC4 byte.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">EVEX prefix. The EVEX 4-byte sequence used for encoding Intel&reg; AVX512 instructions and begins with an 0x62 byte. Intel&reg; APX provides an extended version of the prefix, where the semantics of several payload bits are redefined. The extension is essentially used to provide Intel&reg; APX features for legacy instructions that cannot be provided by other prefixes, such as support for the new data destination (see <a class="el" href="index.html#APX">Intel&reg; APX</a>) or status flags update suppression "no flags" which are represented by the ND and NF bits respectively in the third payload byte. Note that the byte following the extended EVEX prefix is always interpreted as the main opcode byte.</p>
<p class="endli"></p>
</li>
</ul>
<p class="interli">There are somewhat complex rules about which prefixes are allowed, in what order, and in what modes. Intel&reg; XED handles that complexity.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">1-3 opcode bytes. When more than one opcode byte is required the leading bytes (called escapes) are either 0x0F, 0x0F 0x38, or 0x0F 0x3A. With VEX and EVEX prefixes, the escape bytes are encoded differently.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">MODRM byte. Used for addressing memory, refining opcodes, and specifying registers. Optional, but common. It has three fields: the 2-bit "mod", the 3-bit "reg" and 3-bit "r/m" fields.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">SIB byte. Used for specifying memory addressing, optional. It has three fields: the 2-bit scale, 3-bit index, and 3-bit base.</p>
<p class="endli"></p>
</li>
<li>
Displacement bytes. Used for specifying memory offsets, optional. </li>
<li>
Immediate bytes. Optional </li>
</ul>
<p>Immediates and displacements are usually limited to 4 bytes, but several variants of the MOV instruction can take 8B values. The AMD 3DNow ISA extension uses the immediate field to provide additional opcode information.</p>
<p>The legacy prefix bytes are used for: </p><ul>
<li>
operand size overrides (1 prefix), </li>
<li>
address size overrides (1 prefix), </li>
<li>
atomic locking (1 prefix), </li>
<li>
default segment overrides (6 prefixes), </li>
<li>
repeating certain instructions (2 prefixes), and </li>
<li>
opcode refinement. </li>
</ul>
<p>There are 11 distinct legacy prefixes. Three of them (operand size and the two repeat prefixes) have different meanings in different contexts. Sometimes they are used for opcode refinement and do not have their default meaning. Less frequently, two of the segment overrides can be used for conditional branch hints.</p>
<p>There are also multiple ways to encode certain instructions, with the same or differing length.</p>
<p>For additional information on the instruction semantics and encodings: </p><ul>
<li>
<a href="http://www.intel.com/sdm">http://www.intel.com/sdm</a> The Intel&reg; 64 and IA-32 Architectures Software Developers Manuals </li>
<li>
<a href="http://www.intel.com/software/isa">http://www.intel.com/software/isa</a> Information on future ISA extensions. </li>
</ul>
<h2><a class="anchor" id="APX"></a>
Intel® APX</h2>
<p>Intel&reg; Advanced Performance Extensions (Intel&reg; APX) expands the Intel&reg; 64 instruction set architecture with access to more registers and adds various new features that improve general-purpose performance. The extensions are designed to provide efficient performance gains across a variety of workloads without significantly increasing the silicon area or power consumption of the core. The main features of Intel&reg; APX include: </p><ul>
<li>
Extended GPRs, also known as EGPRs (see <a class="el" href="index.html#APX_OPERANDS">Intel&reg; APX Operands</a>) </li>
<li>
Three-operand instructions with a new data destination (NDD); legacy integer instructions can now use EVEX to encode a dedicated destination register operand – turning them into three-operand instructions and reducing the need for extra register move instructions. The NDD receives the result of the computation, and all other operands (including the original destination operand) become read-only source operands </li>
<li>
Legacy-promoted instructions that support status flag update suppression "no flags" (NF); an option for the compiler to suppress the status flags writes of common instructions (no CSPAZO flags, such as Parity, Overflow...) </li>
<li>
Conditional ISA improvements: New conditional load, store and, compare instructions </li>
<li>
Optimized register state save/restore operations </li>
<li>
A new 64-bit absolute direct jump instruction </li>
<li>
Zero Upper (ZU) support for several APX-Promoted instructions, which zero the upper bits of a destination GPR. The destination GPR will get the instruction’s result in bits [OSIZE-1:0] and, if OSIZE &lt; 64b, have its upper bits [63:OSIZE] zeroed </li>
</ul>
<p>Intel&reg; APX instructions' definition by Intel&reg; XED;</p>
<p>Legacy:</p><ul>
<li>Instructions with REX2 prefix are not defined with new iforms or new ISA-SETs</li>
<li>The APXLEGACY extension group includes new APX-F instructions</li>
</ul>
<p>EVEX:</p><ul>
<li>Existing (non-APX) EVEX instructions with EGPRs are not defined with new iforms or new ISA-SETs</li>
<li>Promoted and new instructions are defined with new iforms using the '_APX' suffix</li>
<li>Promoted new data destination instructions with the 'APX_NDD' attribute</li>
<li>Promoted no flags instructions with the 'APX_NF' attribute</li>
<li>The APXEVEX extension group includes new and promoted APX-F instructions</li>
</ul>
<h2><a class="anchor" id="AVX10"></a>
Intel® AVX10</h2>
<p>Intel&reg; Advanced Vector Extensions 10 (Intel&reg; AVX10) establishes a common, converged vector instruction set across all Intel&reg; architectures, incorporating the modern vectorization aspects of Intel&reg; AVX-512.</p>
<p>The Intel&reg; AVX10 architecture introduces several new features and capabilities; </p><ul>
<li>
Introduces a version-based instruction set enumeration </li>
<li>
Allows a converged implementation supported on all Intel&reg; CPUs to include all the existing Intel&reg; AVX-512 capabilities such as EVEX encoding, 32 vector registers and 8 32-bit opmask registers at maximum vector length of 256 (Intel&reg; AVX10/256) </li>
<li>
Allows an implementation to include support for 512-bit vector and 64-bit opmask registers on P-Core CPUs (Intel&reg; AVX10/512) for heavy vector compute applications that can leverage the additional vector length </li>
<li>
Introduces embedded rounding and Suppress All Exceptions (SAE) control for YMM versions of the instructions </li>
</ul>
<h1><a class="anchor" id="OVERVIEW"></a>
Overview of Intel® XED approach</h1>
<p>Intel&reg; XED has two fundamental interfaces: encoding and decoding. Supporting these interfaces are many data structures, but the two starting points are the <a class="el" href="group__ENC.html#ga6f914541ddfa1ffe609acebff72d0b5f">xed_encoder_request_t</a> and the <a class="el" href="group__DEC.html#gacc9a7be76b242c5bf65f56036f5399e6">xed_decoded_inst_t</a> . The <a class="el" href="group__DEC.html#gacc9a7be76b242c5bf65f56036f5399e6">xed_decoded_inst_t</a> has more information than the <a class="el" href="group__ENC.html#ga6f914541ddfa1ffe609acebff72d0b5f">xed_encoder_request_t</a> , but both types are derived from a set of common fields called the <a class="el" href="xed-decoded-inst_8h.html#acc5f47a6c962e198ec5df935002f34e6">xed_operand_values_t</a>.</p>
<p>The output of the decoder, the <a class="el" href="group__DEC.html#gacc9a7be76b242c5bf65f56036f5399e6">xed_decoded_inst_t</a> , includes additional information that is not required for encoding but provides more information about the instruction resources.</p>
<p>The common operand fields, used by both the encoder and decoder, hold the operands and the memory addressing information.</p>
<p>The decoder has an operands array that holds the order of the decoded operands. This array indicates whether or not the operands are read or written.</p>
<p>The encoder has an operand array where the encoder user must specify the order of the operands used for encoding.</p>
<h2><a class="anchor" id="CPUID"></a>
CPUID</h2>
<p>Intel&reg; XED ISA-SETs can be mapped to one or more CPUID groups, each being mapped to one or more CPUID records. The CPUID record contains information about the register containing the bits to be set, the leaf, subleaf and bit indices. When the leaf and subleaf values are loaded into the EAX and ECX registers, respectively, the CPUID instruction sets the specified bits of the specified register, indicating support for the ISA or the feature, which is often the CPUID name field.</p>
<p>Intel&reg; AVX10 introduced a versioned approach for enumeration that ensures that all Intel&reg; CPUs support the same features and instructions at a given Intel&reg; AVX10 version number. This approach also reduced the required number of CPUID feature flags to be checked to determine feature support. This way, usually, it is only needed to check three fields:</p><ol type="1">
<li>A CPUID feature bit indicating that the Intel&reg; AVX10 ISA is supported</li>
<li>A version number to ensure that the supported version is greater than or equal to the desired version</li>
<li>A vector length bit indicating the maximum supported vector length</li>
</ol>
<p>Determining whether an ISA-SET is supported by a chip: For ISA-SETs with a single CPUID group, all of its CPUID records must be set in order to be supported by the chip. For ISA-SETs with multiple CPUID groups, at least one CPUID group must be satisfied. In order to match one group, all of its cpuid records must be set. To simplify things, we can transform it into a logical expression - </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;CPUID GROUP A&quot;</span>                                        OR     <span class="stringliteral">&quot;CPUID GROUP B&quot;</span>                                       OR ...</div>
<div class="line">(<span class="stringliteral">&quot;CPUID RECORD A.A&quot;</span> AND <span class="stringliteral">&quot;CPUID RECORD A.B&quot;</span> AND ... )   OR    (<span class="stringliteral">&quot;CPUID RECORD B.A&quot;</span> AND <span class="stringliteral">&quot;CPUID RECORD B.B&quot;</span> AND ... )   OR ...</div>
</div><!-- fragment --><p> If one CPUID group is satisfied, the whole expression will be satisfied ("OR" relationship), thus indicating chip support for the ISA. Since the CPUID group itself is an "AND" expression between all of its CPUID records, all CPUID records must be set (satisfied) in order to satisfy the sub-expression.</p>
<p>For instance, the ISA-SET AVX512F_512 has the following CPUIDS groups: The Intel&reg; AVX10 CPUID group with three CPUID records: </p><ul>
<li>
CPUID name avx10_enabled, leaf 0x7, sub-leaf 0x1, register EDX, bit 19 </li>
<li>
CPUID name avx10_ver1, leaf 0x24, sub-leaf 0x0, register EBX, bits 0 to 7 </li>
<li>
CPUID name avx10_512vl, leaf 0x24, sub-leaf 0x0, register EBX, bit 18 </li>
</ul>
<p>The feature group with a single CPUID record: </p><ul>
<li>
CPUID name avx512f, leaf 0x7, sub-leaf 0x0, register EBX, bit 16 </li>
</ul>
<p>This means that a chip supports AVX512F_512 ISA if at least one of the two groups has a match. In order to match one CPUID group, all of its records must be set. So either the first group's three CPUID records or the second group's single CPUID record must be set.</p>
<p>To provide further insight on Intel&reg; AVX10 CPUID, let's discuss the first CPUID group of AVX512F_512: The first record ("AVX10 Converged Vector ISA Enable" bit) is indicative of processor support of Intel&reg; AVX10 ISA. The second CPUID record specifies the processor's minimal required Intel&reg; AVX10 version (in this case, AVX10.1). The last CPUID record is the vector length bit indicating the maximum supported VL (512).</p>
<p>For the recommended usage of the Intel&reg; XED CPUID APIS, see <a class="el" href="group__SMALLEXAMPLES.html">Small Examples of using Intel&reg; XED</a> .</p>
<hr  />
 <h1><a class="anchor" id="ICLASS"></a>
Instruction classes</h1>
<p>The <a class="el" href="xed-iclass-enum_8h.html#ad318511ae9cc50f102251b3c91a1ab9f">xed_iclass_enum_t</a> class describes the instruction names. The names are (mostly) taken from the Intel manual, with exceptions only for certain ambiguities. This is what is typically thought of as the instruction mnemonic. Note, Intel&reg; XED does not typically distinguish instructions based on width unless the ISA manuals do so as well. For example, <a class="el" href="xed-iclass-enum_8h.html#ad318511ae9cc50f102251b3c91a1ab9f">xed_iclass_enum_t</a>'s are not suffixed with "w", "l" or "q" typically. There are instructions whose <a class="el" href="xed-iclass-enum_8h.html#ad318511ae9cc50f102251b3c91a1ab9f">xed_iclass_enum_t</a> ends in a "B" or a "Q" (including all byte operations and certain string operations) and those names are preserved as described in the Intel programmers' reference manuals.</p>
<h2><a class="anchor" id="SPECIAL"></a>
Special Cases</h2>
<p>There are many special cases that must be accounted for in attempting to handle all the nuances of the ISA. This is an attempt to explain the nonstandard handling of certain instruction names.</p>
<p>The FAR versions of 3 opcodes (really 6 distinct opcodes) are given the opcode names CALL_FAR, JMP_FAR, and RET_FAR. The AMD documentation lists the far return as RETF. I call that RET_FAR to be consistent with the other far operations.</p>
<p>To distinguish the SSE2 MOVSD instruction from the base string instruction MOVSD, Intel&reg; XED calls the SSE version MOVSD_XMM.</p>
<p>In March 2015, a change was made to certain Intel&reg; XED iclasses to simplify the implementation. The changes are as follows: </p><ul>
<li>
XED_ICLASS_JRCXZ was split in to three distinct iclasses: XED_ICLASS_JCXZ, XED_ICLASS_JECXZ and XED_ICLASS_JRCXZ. </li>
<li>
The REP-prefixed (0xF2, 0xF3) string instructions were split in to new iclasses making them distinct from the underlying non-REP-prefixed instructions. For example XED_ICLASS_REP_STOSW is distinct from XED_ICLASS_STOSW. The CMPS{B,W,D,Q} and SCAS{B,W,D,Q} instructions have "REPE_" or "REPNE_" prefixes to correspond to REPE (0xF3) or REPNE (0xF2). </li>
<li>
LOCK-prefixed (0xF0) atomic read-modify-write memory instructions were split in to separate iclasses that contain the substring "_LOCK". LOCK-prefixed instructions had an attribute XED_ATTRIBUTE_LOCKED. Memory instructions that could have a lock prefix added to them when encoding, have an attribute XED_ATTRIBUTE_LOCKABLE. For example, XED_ICLASS_CMPXCHG16B_LOCK has a lock prefix, but XED_ICLASS_CMPXCHG16B does not have a lock prefix. As always, XCHG is atomic with or without a LOCK prefix as per the rules of the ISA, so XED_ICLASS_XCHG does not have a _LOCK suffix in the xed_iclass_enum_t name. </li>
</ul>
<h2><a class="anchor" id="NOPs"></a>
NOPs</h2>
<p>NOPs are very special. Intel&reg; XED allows for encoding NOPs of 1 to 9 bytes through the use of the XED_ICLASS_NOP (the one-byte nop), and XED_ICLASS_NOP2 ... XED_ICLASS_NOP9. These use the recommended NOP sequences from the Intel&reg; 64 and IA-32 Architectures Software Developers Manual.</p>
<p>The instruction 0x90 is very special in the instruction set because it gets special treatment in 64b mode. In 64b mode, 32b register writes normally zero the upper 32 bits of a 64b register. Not so for 0x90. If it did zero the upper 32 bits, it would not be a NOP.</p>
<p>There are two important NOP categories. XED_CATEGORY_NOP and XED_CATEGORY_WIDENOP. The XED_CATEGORY_NOP applies only to the 0x90 opcode. The WIDENOP category applies to the NOPs in the two-byte table row 0F19...0F1F. The WIDENOPs take MODRM bytes, and optional SIB and displacements.</p>
<hr  />
 <h1><a class="anchor" id="X86-OPERANDS"></a>
Operands</h1>
<p>Intel&reg; XED uses the operand order documented in the Intel Programmers' Reference Manual. In most cases, the first operand is a source and destination (read and written) and the second operand is just a source (read).</p>
<p>For decode requests (<a class="el" href="group__DEC.html#gacc9a7be76b242c5bf65f56036f5399e6">xed_decoded_inst_t</a>), the operands array is stored in the <a class="el" href="group__DEC.html#ga7e5fc2fec01824b7692f9055cae1e04b">xed_inst_t</a> structure once the instruction is decoded. The request's operand order is stored in the <a class="el" href="group__ENC.html#ga6f914541ddfa1ffe609acebff72d0b5f">xed_encoder_request_t</a> for encode requests.</p>
<p>There are several types of operands: </p><ul>
<li>
registers (<a class="el" href="xed-reg-enum_8h.html#af05c33c5a68e9304d1d8ac0408ae3f61">xed_reg_enum_t</a>) </li>
<li>
branch displacements <br  />
 </li>
<li>
memory operations (which include base, index, segment and memory displacements) </li>
<li>
immediates </li>
<li>
pseudo resources (which are listed in the <a class="el" href="xed-reg-enum_8h.html#af05c33c5a68e9304d1d8ac0408ae3f61">xed_reg_enum_t</a>) </li>
</ul>
<p>Each operand has two associated attributes: the R/W action and a visibility. The R/W actions (<a class="el" href="xed-operand-action-enum_8h.html#a6bf8113365b84b9d6ab549fdfef2643f">xed_operand_action_enum_t</a>) indicate whether the operand is read, written or both read-and-written, or conditionally read or written. The visibility attribute (<a class="el" href="xed-operand-visibility-enum_8h.html#ae678c6279a7ba50bf58f2e357242b58d">xed_operand_visibility_enum_t</a>) is described in the next subsection.</p>
<p>The memory operation operand is really a pointer to separate fields that hold the memory operation information. The memory operation information is comprised of the following: </p><ul>
<li>
a segment register </li>
<li>
a base register </li>
<li>
an index register </li>
<li>
a displacement </li>
</ul>
<p>There are several important things to note: </p><ul>
<li>
<p class="startli">There can only be two memory operations, MEM0 and MEM1.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">MEM0 could also be an AGEN, which stands for "Address
         Generation". AGEN is a special operand that uses memory information but does not actually read memory. This is only used for the LEA instruction.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">There can only be an index and displacement associated with MEM0 (or AGEN).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">There is just one displacement associated with the common fields. It could be associated with either the AGEN/MEM0 or with a branch or call instruction.</p>
<p class="endli"></p>
</li>
</ul>
<h2><a class="anchor" id="AVX512_OPERANDS"></a>
Intel® AVX512 Operands</h2>
<p>Intel&reg; AVX512 adds write masking, merging, and zeroing to the instruction set via the EVEX encodings. Write masking, merging, and zeroing are properties of the instruction encoding and are not visible by looking at individual operands. Write masking with merging makes it possible for values of the destination register to live on from prior to the execution of the instruction. Write masking with merging results in an extra register read of the destination operand. In contrast write masking with zeroing always completely overwrites the destination operand, either with values computed by the instruction or with zeros for elements that are "masked off".</p>
<p>For most operands, to learn if the operand reads or writes its associated resource, one can use <a class="el" href="group__DEC.html#gae5299214951891952401b5061e48a6ca">xed_operand_rw</a>(const xed_operand_t* p). However, because masking, merging and zeroing are properties of the instruction, and not just the operand, use of a different function is required.</p>
<p>To handle this, Intel&reg; XED has a new interface function <a class="el" href="group__DEC.html#ga5540113a3dfdf1472de90fdf7953cb5d" title="Interpret the operand action in light of AVX512 masking and zeroing/merging.">xed_decoded_inst_operand_action()</a>, which takes a <a class="el" href="group__DEC.html#gacc9a7be76b242c5bf65f56036f5399e6">xed_decoded_inst_t</a> pointer and an operand index and indicates how the read/write behavior is modified in the presence of masking with merging or masking with zeroing.</p>
<p>The following list attempts to summarize how the value returned from <a class="el" href="group__DEC.html#gae5299214951891952401b5061e48a6ca">xed_operand_rw()</a> is internally modified for the 0th operand, except for stores: </p><ul>
<li>
no masking: no change. </li>
<li>
masking with zeroing: no change. </li>
<li>
masking with merging : destination register operands that are nominally "rw" or "w" become "rcw" indicating a read with a conditional write. </li>
</ul>
<h2><a class="anchor" id="APX_OPERANDS"></a>
Intel® APX Operands</h2>
<p>2023 saw the introduction of Intel&reg; Advanced Performance Extensions (Intel&reg; APX), which expands the entire x86 instruction set with access to more registers. Intel&reg; APX doubles the number of general-purpose registers (GPRs) from 16 to 32 (Extended GPRs or EGPRs).</p>
<p>New and promoted APX-F instructions are defined in one of the following Intel&reg; XED extension groups:</p><ul>
<li>XED_EXTENSION_APXLEGACY: For new APX-F instructions within the Legacy encoding space</li>
<li>XED_EXTENSION_APXEVEX: For new and promoted APX-F instructions within the EVEX encoding space</li>
</ul>
<p>CCMP and CTEST are two new sets of instructions for conditional CMP and TEST, respectively. These instructions introduce a new 4-bit pseudo-register for "Default Flags Values" called DFV (EVEX.[OF, SF, ZF, CF]).</p>
<p>The register index represents the bits for the default flags, for example, DFV10.index == 10 == 0b1010 -&gt; OF=1, SF=0, ZF=1, CF=0. The DFV pseudo-register should be explicitly defined in an encoder request.</p>
<p>The <a class="el" href="group__DEC.html#gaf12b60b6cc0906ebc1ad36ba4d43035e">xed_decoded_inst_get_dfv_reg()</a> API can be used to retrieve a DFV register enumeration from a decoded instruction. The <a class="el" href="group__FLAGS.html#ga1e6bf5fadd96a36207f7f16244f0cb43">xed_flag_dfv_get_default_flags_values()</a> API can be used to get the default flags values given a DFV register enumeration.</p>
<p>Developers can, however, dynamically disable Intel&reg; APX architecture encoder support using the 'NO_APX' API <a class="el" href="xed-operand-accessors_8h.html#a0d0a166d9efe570f975cb56038144bbe">xed3_operand_set_no_apx()</a>. The <a class="el" href="xed-operand-accessors_8h.html#af21fb45771bf9807dee7a7e2019413ec">xed3_operand_set_must_use_evex()</a> API can also be used for APX promoted instructions in order to force EVEX space upon the encoding request.</p>
<p>Developers wishing to encode No-Flags Intel&reg; APX instructions should set the NF Intel&reg; XED operand.</p>
<h2><a class="anchor" id="OPERAND_VISIBILITY"></a>
Operand Resource Visibilities</h2>
<p>See <a class="el" href="xed-operand-visibility-enum_8h.html#ae678c6279a7ba50bf58f2e357242b58d">xed_operand_visibility_enum_t</a> .</p>
<p>There are three basic types of resource visibilities: </p><ul>
<li>
EXPLICIT (EXPL), </li>
<li>
IMPLICIT (IMPL), and </li>
<li>
IMPLICIT SUPPRESSED (SUPP) (usually referred to as just "SUPPRESSED"). </li>
</ul>
<p>Explicit are what you think they are: resources that are required for the encoding, and for each explicit resource, and there is a field in the corresponding instruction encoding for each explicit resource. The implicit and suppressed resources are more subtle.</p>
<p>SUPP operands are: </p><ul>
<li>
not used in picking an encoding, </li>
<li>
not printed in disassembly, </li>
<li>
not represented using operand bits in the encoding. </li>
</ul>
<p>IMPL operands are: </p><ul>
<li>
used in picking an encoding, </li>
<li>
expressed in disassembly, and </li>
<li>
not represented using operand bits in the encoding (like SUPP). </li>
</ul>
<p>The implicit resources are required for selecting an encoding but do not show up as a specific field in the instruction representation. Implicit resources do show up in a conventional instruction disassembly. In the IA-32 instruction set or Intel64 instruction set, there are many instructions that use EAX or RAX implicitly, for example. Sometimes, the CL or RCX register is implicit. Also, some instructions have an implicit 1 immediate. The opcode you chose fixes your choice of implicit register or immediate.</p>
<p>The suppressed resources are a form of implicit resource, but they are resources not required for encoding. The suppressed operands are not normally displayed in a conventional disassembly. The suppressed operands are emitted by the decoder but are not used when encoding. They are ignored by the encoder. Examples are the stack pointer for PUSH and POP operations. There are many others, like pseudo resources.</p>
<p>The explicit and implicit resources are expressed resources &ndash; they show up in disassembly and are required for encoding. The suppressed resources are considered a kind of implicit resources that are not expressed in ATT System V or Intel disassembly formats.</p>
<p>The suppressed operands are always after the implicit and explicit operands in the operand order. <br  />
</p>
<h2><a class="anchor" id="X87_REG_STACK"></a>
x87 Register stack popping</h2>
<p>The Intel&reg; 64 and IA-32 Architectures Software Developers Manual indicates that "FADDP st2", reads st0, st2 writes st2 and pops the x87 stack. The result ends up in st1 after the instruction executes. That is not how Intel&reg; XED represents the operation. Intel&reg; XED will say that "FADDP st2" reads st0 and st2 and writes st2. The output register that Intel&reg; XED provides is essentially "pre
pop". The pop occurs afterward, conceptually. The actual result ends up in the st1 register after the stack pop operation. Intel&reg; XED also lists the pseudo resources indicating that a stack pop has occurred. This behavior affects the output register of the following instructions: FADDP, FMULP, FSUBRP, FSUBP, FDIVRP, FDIVP.</p>
<h2><a class="anchor" id="PSEUDO_RESOURCES"></a>
Pseudo Resources</h2>
<p>Some instructions reference machine registers or perform interesting operations that we need to represent. For example, the IDTR and GDTR are represented as pseudo resources. Operations that pop the x87 floating point register stack can have an X87POP or X87POP2 "register" to indicate if the x87 register stack is popped once or twice. These are part of the <a class="el" href="xed-reg-enum_8h.html#af05c33c5a68e9304d1d8ac0408ae3f61">xed_reg_enum_t</a>.</p>
<h2><a class="anchor" id="IMM_DIS"></a>
Immediates and Displacements</h2>
<p>Using the API functions for setting immediates, memory displacements, and branch displacements. Immediates and Displacements are stored in normal integers internally, but they are stored endian swapped and left justified. The API functions take care of all the endian swapping and positioning so you don't have to worry about that detail.</p>
<p>Immediates and displacements are different things in the ISA. They can be 1, 2, 4 or 8 bytes. Branch displacements (1, 2 or 4 bytes) and Memory displacements (1, 2, 4 or 8 bytes) refer to the signed constants that are used for relative distances or memory "offsets" from a base register (including the instruction pointer) or start of a memory region.</p>
<p>Immediates are signed or unsigned and are used for numerical computations and shift distances. They also hold things like segment selectors for far pointers for certain jump or call instructions.</p>
<p>There is also a second 1B immediate used only for the ENTER instruction.</p>
<p>Intel&reg; XED will try to use the shortest allowed width for a displacement or immediate. You can control Intel&reg; XED's selection of allowed widths using a notion of "legal widths". A "legal width" is a binary number where each bit represents a legal desired width. For example, when you have a valid base register in 32 or 64b addressing, and a displacement is required, your displacement must be either 1 byte or 4 bytes long. This is expressed by OR'ing 1 and 4 together to get 0101 (base 2) or 5 (base 10).</p>
<p>If a four-byte displacement was required, but the value was representable in fewer than four bytes, then the legal width should be set to 0100 (base 2) or 4 (base 10).</p>
<h1><a class="anchor" id="API_REF"></a>
API Reference</h1>
<ul>
<li><a class="el" href="group__INIT.html">INIT</a> Initialization</li>
<li><a class="el" href="group__DEC.html">DEC</a> Decoding instructions</li>
<li><a class="el" href="group__ENC.html">ENC</a> Generic API for encoding instructions</li>
<li><a class="el" href="group__ENCHL.html">ENCHL</a> High level API for the generic encoder</li>
<li><a class="el" href="group__ENCHLPATCH.html">ENCHLPATCH</a> Patching instructions</li>
<li><a class="el" href="group__ENC2.html">ENC2</a> Fast encoder for specific instructions</li>
<li><a class="el" href="group__OPERANDS.html">OPERANDS</a> Operand storage fields</li>
<li><a class="el" href="group__IFORM.html">IFORM</a> Iforms</li>
<li><a class="el" href="group__ISASET.html">ISASET</a> ISA-sets and chips</li>
<li><a class="el" href="group__PRINT.html">PRINT</a> Printing (disassembling) instructions</li>
<li><a class="el" href="group__REGINTFC.html">REGINTFC</a> Register interface functions</li>
<li><a class="el" href="group__FLAGS.html">FLAGS</a> Flags interface functions</li>
<li><a class="el" href="group__AGEN.html">AGEN</a> Address generation calculation support</li>
<li><a class="el" href="group__ENUM.html">ENUM</a> Enumerations</li>
<li><a class="el" href="group__EXAMPLES.html">Examples</a> Examples</li>
</ul>
<h1><a class="anchor" id="LEGAL"></a>
Disclaimer and Legal Information</h1>
<p>The information in this manual is subject to change without notice and Intel Corporation assumes no responsibility or liability for any errors or inaccuracies that may appear in this document or any software that may be provided in association with this document. This document and the software described in it are furnished under license and may only be used or copied in accordance with the terms of the license. No license, express or implied, by estoppel or otherwise, to any intellectual property rights is granted by this document. The information in this document is provided in connection with Intel products and should not be construed as a commitment by Intel Corporation.</p>
<p>EXCEPT AS PROVIDED IN INTEL'S TERMS AND CONDITIONS OF SALE FOR SUCH PRODUCTS, INTEL ASSUMES NO LIABILITY WHATSOEVER, AND INTEL DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY, RELATING TO SALE AND/OR USE OF INTEL PRODUCTS INCLUDING LIABILITY OR WARRANTIES RELATING TO FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABILITY, OR INFRINGEMENT OF ANY PATENT, COPYRIGHT OR OTHER INTELLECTUAL PROPERTY RIGHT. Intel products are not intended for use in medical, life saving, life sustaining, critical control or safety systems, or in nuclear facility applications.</p>
<p>Designers must not rely on the absence or characteristics of any features or instructions marked "reserved" or "undefined." Intel reserves these for future definition and shall have no responsibility whatsoever for conflicts or incompat- ibilities arising from future changes to them.</p>
<p>The software described in this document may contain software defects that may cause the product to deviate from published specifications. Current characterized software defects are available on request.</p>
<p>Intel, the Intel logo, Intel SpeedStep, Intel NetBurst, Intel NetStructure, MMX, Intel386, Intel486, Celeron, Intel Centrino, Intel Xeon, Intel XScale, Itanium, Pentium, Pentium II Xeon, Pentium III Xeon, Pentium M, and VTune are trademarks or registered trademarks of Intel Corporation or its subsidiaries in the United States and other countries.</p>
<p>Other names and brands may be claimed as the property of others.</p>
<p>Copyright (c) 2002-2023 Intel Corporation. All Rights Reserved. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
