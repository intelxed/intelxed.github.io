<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>X86 Encoder Decoder: X86 Encoder Decoder User Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">X86 Encoder Decoder
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">X86 Encoder Decoder User Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>by Mark Charney</p>
<p>2018-02-27</p>
<h1><a class="anchor" id="INTRO"></a>
Introduction</h1>
<p>XED is an acronym for X86 Encoder Decoder. The latter part is pronounced like the (British) English "z".</p>
<p>Intel XED is a software library (and associated headers) written in C for encoding and decoding X86 (IA-32 instruction set and Intel&reg; 64 instruction set) instructions. The decoder takes sequences of 1-15 bytes along with machine mode information and produces a data structure describing the opcode and operands, and flags. The encoder takes a similar data structure and produces a sequence of 1 to 15 bytes. Intel XED is multi-thread safe.</p>
<p>Intel XED was designed to be very fast and extensible.</p>
<p>Intel XED compiles with the following compilers: </p><ul>
<li>
GNU GCC </li>
<li>
Microsoft Visual Studio </li>
<li>
Intel ICL/ICC </li>
<li>
LLVM/Clang </li>
</ul>
<p>Intel XED works with the following operating systems: </p><ul>
<li>
Linux </li>
<li>
Microsoft Windows (with and without cygwin) </li>
<li>
Apple Mac OS X* </li>
<li>
FreeBSD </li>
</ul>
<p>The Intel XED examples (<a class="el" href="group__EXAMPLES.html">Examples of using Intel XED</a>) also include binary image readers for Windows PECOFF, ELF and Mac OS X* MACHO binary file formats for 32b and 64b. These allow Intel XED to be used as a simple (not symbolic) disassembler. The Intel XED disassembler supports 3 output formats: Intel, ATT SYSV, and a more detailed internal format describing all resources read and written.</p>
<h1><a class="anchor" id="TOC"></a>
Table of Contents</h1>
<ul>
<li><a class="el" href="index.html#BUILD">Building</a> Building your program with Intel XED</li>
<li><a class="el" href="index.html#EXTERN">External</a> External Requirements</li>
<li><a class="el" href="index.html#TERMS">Terms</a> Terminology</li>
<li><a class="el" href="index.html#OVERVIEW">Overview</a> Overview of the Intel XED approach</li>
<li><a class="el" href="index.html#API_REF">API reference</a> Detailed descriptions of the API</li>
<li><a class="el" href="group__EXAMPLES.html">Examples</a> Examples</li>
<li><a class="el" href="index.html#LEGAL">Disclaimer and Legal Information</a></li>
</ul>
<h1><a class="anchor" id="BUILD"></a>
Building your program using Intel XED.</h1>
<p>This section describes the requirements for compiling with Intel XED and linking the libxed.a library. It assumes you are building from a Intel XED kit, and not directly from the sources. (See the "install" option in the Intel XED build manual for information on making kits).</p>
<p>The structure of a Intel XED kit is as follows: </p><div class="fragment"><div class="line">               |-bin------</div><div class="line">               |-doc------|-html-</div><div class="line">               |-examples-</div><div class="line">|-xed-kit-name-|-include--</div><div class="line">               |-lib------</div><div class="line">               |-misc-----</div></div><!-- fragment --><p>To use Intel XED your sources should include the top-most header file: <a class="el" href="xed-interface_8h.html">xed-interface.h</a>.</p>
<p>Your compilation statement must include: </p><div class="fragment"><div class="line">-Ixed-kit-name/include</div></div><!-- fragment --><p> where "xed-kit-name" is the place you've unpacked the Intel XED kit.</p>
<p>Your Linux or Mac OS X* link statement must reference the libxed library: </p><div class="fragment"><div class="line">-lxed-kit-name/lib/libxed.a</div></div><!-- fragment --><p>(or link against libxed.lib for Windows).</p>
<p>Intel XED uses base types with the following names: xed_uint8_t, xed_uint16_t, xed_uint32_t, xed_uint64_t xed_int8_t, xed_int16_t, xed_int32_t, and xed_int64_t. Intel XED also defines a "xed_uint_t" type that is shorthand for "unsigned int".</p>
<p>Please see the section <a class="el" href="group__INIT.html">Intel XED initialization</a> for more information about using Intel XED, and also the examples in <a class="el" href="group__EXAMPLES.html">Examples of using Intel XED</a>.</p>
<h1><a class="anchor" id="EXTERN"></a>
External Requirements</h1>
<p>Intel XED was designed to have minimal external requirements. Intel XED makes no system calls. Intel XED allocates no memory. (The examples are different). The following external functions/symbols are required for linking a program with libxed, with one caveat: The functions fprint and abort and the data object stderr are optional. If users register their own abort handler using <a class="el" href="group__INIT.html#ga017b6fcac483ea9f1621c4cdd0af84bd" title="This is for registering a function to be called during XED&#39;s assert processing. ">xed_register_abort_function</a> () , then fprintf, stderr and abort are not required and can be stubbed out to satisfy the linker.</p>
<p>Required: </p><ul>
<li>
memcmp </li>
<li>
memcpy </li>
<li>
memset </li>
<li>
strcmp </li>
<li>
strlen </li>
<li>
strncat </li>
</ul>
<p>Optional: </p><ul>
<li>
abort </li>
<li>
fprintf </li>
<li>
stderr </li>
</ul>
<h1><a class="anchor" id="TERMS"></a>
Terminology</h1>
<p>X86 instructions are 1-15 byte values. They consist of several well-defined components: </p><ul>
<li>
<p class="startli">Prefix bytes. </p><ul>
<li>
<p class="startli">Legacy prefix bytes used for many purposes (described further below).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">REX prefix byte but only in 64b mode. It has 4 1-bit fields: W, R, X, and B. The W bit modifies the operation width. The R, X and B fields extend the register encodings. The REX byte must be right before the opcode bytes else it is ignored.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">VEX prefix byte sequence. The VEX prefix is used mostly for AVX1 and AVX2 instructions as well as BMI1/2 instructions and mask operations in Intel&reg; AVX512. The VEX prefix comes in two forms. The 2-byte sequence begins with an 0xC5 byte. The 3-byte sequence begins with an 0xC4 byte.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">EVEX prefix. The EVEX 3-byte sequence used for encoding Intel AVX512 instructions and begins with an 0x62 byte.</p>
<p class="endli"></p>
</li>
</ul>
<p>There are somewhat complex rules about which prefixes are allowed, in what order, and in what modes. Intel XED handles that complexity.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">1-3 opcode bytes. When more than one opcode byte is required the leading bytes (called escapes) are either 0x0F, 0x0F 0x38 or 0x0F 0x3A. With VEX and EVEX prefixes, the escape bytes are encoded differently.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">MODRM byte. Used for addressing memory, refining opcodes, specifying registers. Optional, but common. It has 3 fields: the 2-bit "mod", the 3-bit "reg" and 3-bit "r/m" fields.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">SIB byte. Used for specifying memory addressing, optional. It has 3 fields: the 2-bit scale, 3-bit index and 3-bit base.</p>
<p class="endli"></p>
</li>
<li>
Displacement bytes. Used for specifying memory offsets, optional. </li>
<li>
Immediate bytes. Optional </li>
</ul>
<p>Immediates and displacements are usually limited to 4 bytes, but there are several variants of the MOV instruction that can take 8B values. The AMD 3DNow ISA extension uses the immediate field to provide additional opcode information.</p>
<p>The legacy prefix bytes are used for: </p><ul>
<li>
operand size overrides (1 prefix), </li>
<li>
address size overrides (1 prefix), </li>
<li>
atomic locking (1 prefix), </li>
<li>
default segment overrides (6 prefixes), </li>
<li>
repeating certain instructions (2 prefixes), and </li>
<li>
opcode refinement. </li>
</ul>
<p>There are 11 distinct legacy prefixes. Three of them (operand size, and the two repeat prefixes) have different meanings in different contexts; Sometimes they are used for opcode refinement and do not have their default meaning. Less frequently, two of the segment overrides can be used for conditional branch hints.</p>
<p>There are also multiple ways to encode certain instructions, with the same or differing length.</p>
<p>For additional information on the instruction semantics and encodings: </p><ul>
<li>
<a href="http://www.intel.com/sdm">http://www.intel.com/sdm</a> The Intel&reg; 64 and IA-32 Architectures Software Developers Manuals </li>
<li>
<a href="http://www.intel.com/software/isa">http://www.intel.com/software/isa</a> Information on future ISA extensions. </li>
</ul>
<h1><a class="anchor" id="OVERVIEW"></a>
Overview of XED approach</h1>
<p>XED has two fundamental interfaces: encoding and decoding. Supporting these interfaces are many data structures, but the two starting points are the <a class="el" href="group__ENC.html#ga6f914541ddfa1ffe609acebff72d0b5f">xed_encoder_request_t</a> and the <a class="el" href="group__DEC.html#gac566768d37da62eafbbda459f6fec3ac" title="The main container for instructions. ">xed_decoded_inst_t</a> . The <a class="el" href="group__DEC.html#gac566768d37da62eafbbda459f6fec3ac" title="The main container for instructions. ">xed_decoded_inst_t</a> has more information than the <a class="el" href="group__ENC.html#ga6f914541ddfa1ffe609acebff72d0b5f">xed_encoder_request_t</a> , but both types are derived from a set of common fields called the <a class="el" href="xed-decoded-inst_8h.html#acc5f47a6c962e198ec5df935002f34e6">xed_operand_values_t</a>.</p>
<p>The output of the decoder, the <a class="el" href="group__DEC.html#gac566768d37da62eafbbda459f6fec3ac" title="The main container for instructions. ">xed_decoded_inst_t</a> , includes additional information that is not required for encoding, but provides more information about the instruction resources.</p>
<p>The common operand fields, used by both the encoder and decoder, hold the operands and the memory addressing information.</p>
<p>The decoder has an operands array that holds order of the decoded operands. This array indicates whether or not the operands are read or written.</p>
<p>The encoder has an operand array where the encoder user must specify the order of the operands used for encoding. </p><hr/>
 <h1><a class="anchor" id="ICLASS"></a>
Instruction classes</h1>
<p>The <a class="el" href="xed-iclass-enum_8h.html#ad318511ae9cc50f102251b3c91a1ab9f">xed_iclass_enum_t</a> class describes the instruction names. The names are (mostly) taken from the Intel manual, with exceptions only for certain ambiguities. This is what is typically thought of as the instruction mnemonic. Note, Intel XED does not typically distinguish instructions based on width unless the ISA manuals do so as well. For example, <a class="el" href="xed-iclass-enum_8h.html#ad318511ae9cc50f102251b3c91a1ab9f">xed_iclass_enum_t</a>'s are not suffixed with "w", "l" or "q" typically. There are instructions whose <a class="el" href="xed-iclass-enum_8h.html#ad318511ae9cc50f102251b3c91a1ab9f">xed_iclass_enum_t</a> ends in a "B" or a "Q" (including all byte operations and certain string operations) and those names are preserved as described in the Intel programmers' reference manuals.</p>
<h2><a class="anchor" id="SPECIAL"></a>
Special Cases</h2>
<p>There are many special cases that must be accounted for in attempting to handle all the nuances of the ISA. This is an attempt to explain the nonstandard handling of certain instruction names.</p>
<p>The FAR versions of 3 opcodes (really 6 distinct opcodes) are given the opcode names CALL_FAR, JMP_FAR and RET_FAR. The AMD documentation lists the far return as RETF. I call that RET_FAR to be consistent with the other far operations.</p>
<p>To distinguish the SSE2 MOVSD instruction from the base string instruction MOVSD, Intel XED calls the SSE version MOVSD_XMM.</p>
<p>In March 2015, a change was made to certain Intel XED iclasses to simplify the implementation. The changes are as follows: </p><ul>
<li>
XED_ICLASS_JRCXZ was split in to 3 distinct iclasses: XED_ICLASS_JCXZ, XED_ICLASS_JECXZ and XED_ICLASS_JRCXZ. </li>
<li>
The REP-prefixed (0xF2, 0xF3) string instructions were split in to new iclasses making tqhem distinct from the underlying non-REP-prefixed instructions. For example XED_ICLASS_REP_STOSW is distinct from XED_ICLASS_STOSW. And the CMPS{B,W,D,Q} and SCAS{B,W,D,Q} instructions have "REPE_" or "REPNE_" prefixes to correspond to REPE (0xF3) or REPNE (0xF2). </li>
<li>
LOCK-prefixed (0xF0) atomic read-modify-write memory instructions were split in to separate iclasses that contain the substring "_LOCK". LOCK-prefixed instructions have an attribute XED_ATTRIBUTE_LOCK. Memory instructions that could have a lock prefix added to them when encoding, have an attribute XED_ATTRIBUTE_LOCKABLE. For example XED_ICLASS_CMPXCHG16B_LOCK has a lock prefix, but XED_ICLASS_CMPXCHG16B does not have a lock prefix. As always XCHG is atomic with our without a LOCK prefix as per the rules of the ISA, so XED_ICLASS_XCHG does not have a _LOCK suffix in the xed_iclass_enum_t name. </li>
</ul>
<h2><a class="anchor" id="NOPs"></a>
NOPs</h2>
<p>NOPs are very special. Intel XED allows for encoding NOPs of 1 to 9 bytes through the use of the XED_ICLASS_NOP (the one byte nop), and XED_ICLASS_NOP2 ... XED_ICLASS_NOP9. These use the recommended NOP sequences from the Intel&reg; 64 and IA-32 Architectures Software Developers Manual.</p>
<p>The instruction 0x90 is very special in the instruction set because it gets special treatment in 64b mode. In 64b mode, 32b register writes normally zero the upper 32 bits of a 64b register. Not so for 0x90. If it did zero the upper 32 bits, it would not be a NOP.</p>
<p>There are two important NOP categories. XED_CATEGORY_NOP and XED_CATEGORY_WIDENOP. The XED_CATEGORY_NOP applies only to the 0x90 opcode. The WIDENOP category applies to the NOPs in the two byte table row 0F19...0F1F. The WIDENOPs take MODRM bytes, and optional SIB and displacements. </p><hr/>
 <h1><a class="anchor" id="X86-OPERANDS"></a>
Operands</h1>
<p>Intel XED uses the operand order documented in the Intel Programmers' Reference Manual. In most cases, the first operand is a source and destination (read and written) and the second operand is just a source (read).</p>
<p>For decode requests (<a class="el" href="group__DEC.html#gac566768d37da62eafbbda459f6fec3ac" title="The main container for instructions. ">xed_decoded_inst_t</a>), the operands array is stored in the <a class="el" href="group__DEC.html#ga4410c86154ad601e0440a075864f9c4b" title="constant information about a decoded instruction form, including the pointer to the constant operand ...">xed_inst_t</a> strcture once the instruction is decoded. For encode requests, the request's operand order is stored in the <a class="el" href="group__ENC.html#ga6f914541ddfa1ffe609acebff72d0b5f">xed_encoder_request_t</a>.</p>
<p>There are several types of operands: </p><ul>
<li>
registers (<a class="el" href="xed-reg-enum_8h.html#af05c33c5a68e9304d1d8ac0408ae3f61">xed_reg_enum_t</a>) </li>
<li>
branch displacements </li>
<li>
memory operations (which include base, index, segment and memory displacements) </li>
<li>
immediates </li>
<li>
pseudo resources (which are listed in the <a class="el" href="xed-reg-enum_8h.html#af05c33c5a68e9304d1d8ac0408ae3f61">xed_reg_enum_t</a>) </li>
</ul>
<p>Each operand has two associated attributes: the R/W action and a visibility. The R/W actions (<a class="el" href="xed-operand-action-enum_8h.html#a6bf8113365b84b9d6ab549fdfef2643f">xed_operand_action_enum_t</a>) indicate whether the operand is read, written or both read-and-written, or conditionally read or written. The visibility attribute (<a class="el" href="xed-operand-visibility-enum_8h.html#ae678c6279a7ba50bf58f2e357242b58d">xed_operand_visibility_enum_t</a>) is described in the next subsection.</p>
<p>The memory operation operand is really a pointer to separate fields that hold the memory operation information. The memory operation information is comprised of: </p><ul>
<li>
a segment register </li>
<li>
a base register </li>
<li>
an index register </li>
<li>
a displacement </li>
</ul>
<p>There are several important things to note: </p><ul>
<li>
There can only be two memory operations, MEM0 and MEM1. </li>
<li>
MEM0 could also be an AGEN &ndash; a special operand that uses memory information but does not actually read memory. This is only used for the LEA instruction. </li>
<li>
There can only be an index and displacement associated with MEM0. </li>
<li>
There is just one displacement associated with the common fields. It could be associated with either the AGEN/MEM0 or with a branch or call instruction. </li>
</ul>
<h2><a class="anchor" id="AVX512_OPERANDS"></a>
Intel® AVX512 Operands</h2>
<p>Intel&reg; AVX512 adds write masking, merging and zeroing to the instruction set via the EVEX encodings. Write masking, merging and zeroing are properties of the instruction encoding and are not visible by looking at individual operands. Write masking with merging makes it possible for values of the destination register to live on from prior to the execution of the instruction. Write masking with merging results in an extra register read of the destination operand. In contrast write masking with zeroing always completely overwrites the destination operand, either with values computed by the instruction or with zeros for elements that are "masked off".</p>
<p>For most operands, to learn if the operand reads or writes its associated resource, one can use <a class="el" href="group__DEC.html#gae5299214951891952401b5061e48a6ca" title="DEPRECATED: Returns the raw R/W action. ">xed_operand_rw</a>(const xed_operand_t* p). However because masking, merging and zeroing are properties of the instruction, and not just the operand, use of a different function is required.</p>
<p>To handle this, Intel XED has a new interface function <a class="el" href="group__DEC.html#ga5540113a3dfdf1472de90fdf7953cb5d" title="Interpret the operand action in light of AVX512 masking and zeroing/merging. ">xed_decoded_inst_operand_action()</a> which takes a <a class="el" href="group__DEC.html#gac566768d37da62eafbbda459f6fec3ac" title="The main container for instructions. ">xed_decoded_inst_t</a> pointer and an operand index and indicates how the read/write behavior is modified in the presence of masking with merging or masking with zeroing.</p>
<p>The following list attempts to summarize how the value returned from <a class="el" href="group__DEC.html#gae5299214951891952401b5061e48a6ca" title="DEPRECATED: Returns the raw R/W action. ">xed_operand_rw()</a> is internally modified for the 0th operand, except for stores: </p><ul>
<li>
no masking: no change. </li>
<li>
masking with zeroing: no change. </li>
<li>
masking with merging : destination register operands that are nominally "rw" or "w" become "rcw" indicating a read with a conditional write. </li>
</ul>
<h2><a class="anchor" id="OPERAND_VISIBILITY"></a>
Operand Resource Visibilities</h2>
<p>See <a class="el" href="xed-operand-visibility-enum_8h.html#ae678c6279a7ba50bf58f2e357242b58d">xed_operand_visibility_enum_t</a> .</p>
<p>There are 3 basic types of resource visibilites: </p><ul>
<li>
EXPLICIT (EXPL), </li>
<li>
IMPLICIT (IMPL), and </li>
<li>
IMPLICIT SUPPRESSED (SUPP) (usually referred to as just "SUPPRESSED"). </li>
</ul>
<p>Explicit are what you think they are: resources that are required for the encoding and for each explicit resource, there is field in the corresponding instruction encoding. The implicit and suppressed resources are a more subtle.</p>
<p>SUPP operands are: </p><ul>
<li>
not used in picking an encoding, </li>
<li>
not printed in disassembly, </li>
<li>
not represented using operand bits in the encoding. </li>
</ul>
<p>IMPL operands are: </p><ul>
<li>
used in picking an encoding, </li>
<li>
expressed in disassembly, and </li>
<li>
not represented using operand bits in the encoding (like SUPP). </li>
</ul>
<p>The implicit resources are required for selecting an encoding, but do not show up as a specific field in the instruction representation. Implicit resources do show up in a conventional instruction disassembly. In the IA-32 instruction set or Intel64 instruction set, there are many instructions that use EAX or RAX implicitly, for example. Sometimes the CL or RCX register is implicit. Also, some instructions have an implicit 1 immediate. The opcode you chose fixes your choice of implicit register or immediate.</p>
<p>The suppressed resources are a form of implicit resource, but they are resources not required for encoding. The suppressed operands are not normally displayed in a conventional disassembly. The suppressed operands are emitted by the decoder but are not used when encoding. They are ignored by the encoder. Examples are the stack pointer for PUSH and POP operations. There are many others, like pseudo resources.</p>
<p>The explicit and implicit resources are expressed resources &ndash; they show up in disassembly and are required for encoding. The suppressed resources are considered a kind of implicit resources that are not expressed in ATT System V or Intel disassembly formats.</p>
<p>The suppressed operands are always after the implicit and explicit operands in the operand order.</p>
<h2><a class="anchor" id="X87_REG_STACK"></a>
x87 Register stack popping</h2>
<p>The Intel&reg; 64 and IA-32 Architectures Software Developers Manual indicates that "FADDP st2", reads st0, st2 writes st2 and pops the x87 stack. The result ends up in st1 after the instruction executes. That is not how Intel XED represents the operation. Intel XED will say that "FADDP st2" reads st0 and st2 and writes st2. The output register that Intel XED provides is essentially "pre
pop". The pop occurs afterward, conceptually. The actual result ends up in the st1 register after the stack pop operation. Intel XED also lists the pseudo resources indicating that a stack pop has occurred. This behavior affects the output register of following instructions: FADDP, FMULP, FSUBRP, FSUBP, FDIVRP, FDIVP.</p>
<h2><a class="anchor" id="PSEUDO_RESOURCES"></a>
Pseudo Resources</h2>
<p>Some instructions reference machine registers or perform interesting operations that we need to represent. For example, the IDTR and GDTR are represented as pseudo resources. Operations that pop the x87 floating point register stack can have a X87POP or X87POP2 "register" to indicate if the x87 register stack is popped once or twice. These are part of the <a class="el" href="xed-reg-enum_8h.html#af05c33c5a68e9304d1d8ac0408ae3f61">xed_reg_enum_t</a>.</p>
<h2><a class="anchor" id="IMM_DIS"></a>
Immediates and Displacements</h2>
<p>Using the API functions for setting immediates, memory displacements and branch displacements. Immediates and Displacements are stored in normal integers internally, but they are stored endian swapped and left justified. The API functions take care of all the endian swapping and positioning so you don't have to worry about that detail.</p>
<p>Immediates and displacements are different things in the ISA. They can be 1, 2, 4 or 8 bytes. Branch displacements (1, 2 or 4 bytes) and Memory displacements (1, 2, 4 or 8 bytes) refer to the signed constants that are used for relative distances or memory "offsets" from a base register (including the instruction pointer) or start of a memory region.</p>
<p>Immediates are signed or unsigned and are used for numerical computations, shift distances, and also hold things like segment selectors for far pointers for certain jump or call instructions.</p>
<p>There is also a second 1B immediate used only for the ENTER instruction.</p>
<p>Intel XED will try to use the shortest allowed width for a displacement or immediate. You can control Intel XED's selection of allowed widths using a notion of "legal widths". A "legal width" is a binary number where each bit represents a legal desired width. For example, when you have a valid base register in 32 or 64b addressing, and a displacement is required, your displacement must be either 1 byte or 4 bytes long. This is expressed by OR'ing 1 and 4 together to get 0101 (base 2) or 5 (base 10).</p>
<p>If a four byte displacement was required, but the value was representable in fewer than four bytes, then the legal width should be set to 0100 (base 2) or 4 (base 10).</p>
<h1><a class="anchor" id="API_REF"></a>
API Reference</h1>
<ul>
<li><a class="el" href="group__INIT.html">INIT</a> Initialization</li>
<li><a class="el" href="group__DEC.html">DEC</a> Decoding instructions</li>
<li><a class="el" href="group__ENC.html">ENC</a> Encoding instructions</li>
<li><a class="el" href="group__ENCHL.html">ENCHL</a> High level API for encoding instructions</li>
<li><a class="el" href="group__ENCHLPATCH.html">ENCHLPATCH</a> Patching instructions</li>
<li><a class="el" href="group__OPERANDS.html">OPERANDS</a> Operand storage fields</li>
<li><a class="el" href="group__IFORM.html">IFORM</a> Iforms</li>
<li><a class="el" href="group__ISASET.html">ISASET</a> ISA-sets and chips</li>
<li><a class="el" href="group__PRINT.html">PRINT</a> Printing (disassembling) instructions</li>
<li><a class="el" href="group__REGINTFC.html">REGINTFC</a> Register interface functions</li>
<li><a class="el" href="group__FLAGS.html">FLAGS</a> Flags interface functions</li>
<li><a class="el" href="group__AGEN.html">AGEN</a> Address generation calculation support</li>
<li><a class="el" href="group__ENUM.html">ENUM</a> Enumerations</li>
<li><a class="el" href="group__EXAMPLES.html">Examples</a> Examples</li>
</ul>
<h1><a class="anchor" id="LEGAL"></a>
Disclaimer and Legal Information</h1>
<p>The information in this manual is subject to change without notice and Intel Corporation assumes no responsibility or liability for any errors or inaccuracies that may appear in this document or any software that may be provided in association with this document. This document and the software described in it are furnished under license and may only be used or copied in accordance with the terms of the license. No license, express or implied, by estoppel or otherwise, to any intellectual property rights is granted by this document. The information in this document is provided in connection with Intel products and should not be construed as a commitment by Intel Corporation.</p>
<p>EXCEPT AS PROVIDED IN INTEL'S TERMS AND CONDITIONS OF SALE FOR SUCH PRODUCTS, INTEL ASSUMES NO LIABILITY WHATSOEVER, AND INTEL DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY, RELATING TO SALE AND/OR USE OF INTEL PRODUCTS INCLUDING LIABILITY OR WARRANTIES RELATING TO FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABILITY, OR INFRINGEMENT OF ANY PATENT, COPYRIGHT OR OTHER INTELLECTUAL PROPERTY RIGHT. Intel products are not intended for use in medical, life saving, life sustaining, critical control or safety systems, or in nuclear facility applications.</p>
<p>Designers must not rely on the absence or characteristics of any features or instructions marked "reserved" or "undefined." Intel reserves these for future definition and shall have no responsibility whatsoever for conflicts or incompat- ibilities arising from future changes to them.</p>
<p>The software described in this document may contain software defects which may cause the product to deviate from published specifications. Current characterized software defects are available on request.</p>
<p>Intel, the Intel logo, Intel SpeedStep, Intel NetBurst, Intel NetStructure, MMX, Intel386, Intel486, Celeron, Intel Centrino, Intel Xeon, Intel XScale, Itanium, Pentium, Pentium II Xeon, Pentium III Xeon, Pentium M, and VTune are trademarks or registered trademarks of Intel Corporation or its subsidiaries in the United States and other countries.</p>
<p>Other names and brands may be claimed as the property of others.</p>
<p>Copyright (c) 2002-2016 Intel Corporation. All Rights Reserved. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
